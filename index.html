<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Centered Video Grid with Shading and Audio Control</title>
    <style>
        /* Reset margins, paddings, and box sizing */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent scrollbars */
            /* Prevent overscroll on mobile */
            overscroll-behavior: none;
            touch-action: none;
            background-color: black; /* Initial background color */
            /* Removed transition from body */
            position: relative; /* For positioning the mute button and credit */
            font-family: Arial, sans-serif; /* Base font */
        }

        /* Content container with filter transition */
        .content {
            width: 100%;
            height: 100%;
            transition: filter 1s ease-in-out; /* Smooth transition for filters */
        }

        /* Gradient overlay */
        .gradient-overlay {
            position: fixed;
            z-index: 1; /* Overlay above grid items */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(
                circle at center,
                rgba(0, 0, 0, 0) 356px,
                rgba(0, 0, 0, 0) 356px,
                rgba(0, 0, 0, 1) 100%
            );
            pointer-events: none; /* Allow interactions below */
            transition: background 1s ease-in-out; /* Smooth transition for gradient */
        }

        /* Grid container */
        .grid-container {
            position: absolute; /* Enable positioning */
            display: grid; /* Ensure the grid is displayed */
            grid-gap: 0;
            width: 100%;
            height: 100%;
        }

        .grid-item {
            position: relative; /* For stacking context */
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            background-color: #000; /* Fallback background color */
            background-image: url('other.png'); /* Default background image */
            /* Removed individual transitions for grid items */
        }

        /* Styling for the center cell */
        .grid-item.center {
            position: relative; /* Allow video stacking */
            background-image: url('other.png'); /* Default background image */
            background-size: cover; /* Make sure the background covers the area */
            background-position: center;
            cursor: pointer; /* Change cursor to pointer for center grid item */
        }

        /* Style for the video */
        .center-video {
            position: absolute;
            z-index: 2; /* Above the overlay */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            background-color: transparent; /* Ensure transparency is maintained */
            /* Changed pointer-events to auto to allow clicking */
            pointer-events: auto;
            cursor: pointer; /* Change cursor to pointer when over the video */
            /* Removed individual transitions for video */
        }

        /* Mute/Unmute Button */
        .mute-button {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3; /* Above other elements */
            transition: background-color 0.3s ease;
        }

        .mute-button:hover {
            background-color: rgba(255, 255, 255, 0.5);
        }

        .mute-button:focus {
            outline: none;
        }

        /* Icons for mute and unmute */
        .mute-button::before {
            content: 'ðŸ”‡'; /* Default icon: Muted */
            font-size: 20px;
        }

        .mute-button.unmuted::before {
            content: 'ðŸ”Š'; /* Icon when unmuted */
        }

        /* Song Credit */
        .song-credit {
            position: fixed;
            top: 20px; /* Align vertically with mute button */
            right: 70px; /* Positioned to the left of the mute button */
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 14px;
            /* Added font-family for Courier New */
            font-family: "Courier New", monospace;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
            z-index: 3; /* Above other elements */
        }

        .song-credit.visible {
            opacity: 1;
            visibility: visible;
        }

        /* Loading Overlay */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            z-index: 4; /* Above all other elements */
            opacity: 1;
            transition: opacity 3s ease;
            pointer-events: none; /* Allow interactions to pass through */
        }

        #loading-overlay.fade-out {
            opacity: 0;
        }

        /* New: Color Control Buttons */
        .color-control-button {
            position: fixed;
            right: 20px;
            width: 30px; /* Reduced width for smaller size */
            height: 30px; /* Reduced height for smaller size */
            border: none;
            border-radius: 50%; /* Makes the button circular */
            cursor: pointer;
            display: block; /* Ensures buttons stack vertically */
            z-index: 3; /* Above other elements */
            transition: background-color 0.3s ease, transform 0.3s ease;
            margin-top: 10px; /* Space between buttons */
            box-shadow: 0 2px 5px rgba(0,0,0,0.3); /* Optional: Adds a subtle shadow */
        }

        #original-color-button {
            top: 70px; /* Positioned below the song credit */
            background-color: black; /* Black circle for Original */
        }

        #inverted-color-button {
            top: 120px; /* 70px + 30px (button height) + 10px (margin-top) */
            background-color: white; /* White circle for Inverted */
        }

        /* Hover Effects (Optional) */
        .color-control-button:hover {
            transform: scale(1.1); /* Slightly enlarge on hover */
        }

        .color-control-button:focus {
            outline: none;
        }

    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div id="loading-overlay"></div>

    <div class="content">
        <div class="gradient-overlay" id="gradient-overlay"></div> <!-- Radial gradient -->
        <div class="grid-container" id="grid-container">
            <!-- Grid items will be inserted here -->
        </div>
    </div>

    <!-- Mute/Unmute Button -->
    <button class="mute-button" id="mute-button" aria-label="Mute audio"></button>

    <!-- Song Credit -->
    <div class="song-credit" id="song-credit">
        ðŸŽµ Aquarius by Quentin Sirjacq ðŸŽµ
    </div>

    <!-- New: Color Control Buttons -->
    <button class="color-control-button" id="original-color-button" aria-label="Original color scheme"></button>
    <button class="color-control-button" id="inverted-color-button" aria-label="Inverted color scheme"></button>

    <!-- Audio Element -->
    <audio id="background-audio" src="aquarius_siteperso.mp3" loop muted></audio>

    <script>
        // Function to preload images if necessary (optional)
        function preloadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.src = src;
                img.onload = resolve;
                img.onerror = reject;
            });
        }

        let isFirstClick = true; // Flag to track if the first click has occurred

        async function createGrid() {
            const container = document.getElementById('grid-container');

            try {
                container.innerHTML = '';

                const imgOriginalSize = 504; // Replace with your image's original size in pixels
                const displayScale = 0.75;    // Images displayed at 75% of original size
                const minCellSize = 100;      // Minimum cell size in pixels
                const maxCellSize = imgOriginalSize * displayScale; // Maximum cell size

                // Get viewport dimensions considering mobile address bars
                const viewportWidth = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
                const viewportHeight = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);

                // Calculate image display size ensuring the center item is fully visible and responsive
                let cellSize = Math.min(
                    maxCellSize,
                    Math.max(minCellSize, Math.min(viewportWidth, viewportHeight))
                );

                // Calculate number of columns and rows needed to cover the viewport
                let cols = Math.ceil(viewportWidth / cellSize) + 0; // Add extra columns to ensure coverage
                let rows = Math.ceil(viewportHeight / cellSize) + 0; // Add extra rows to ensure coverage

                // Ensure cols and rows are odd numbers to have a center cell
                if (cols % 2 === 0) cols += 1;
                if (rows % 2 === 0) rows += 1;

                // Calculate total grid width and height
                const gridWidth = cols * cellSize;
                const gridHeight = rows * cellSize;

                // Calculate grid container's left and top to center the center cell
                const centerCol = Math.floor(cols / 2);
                const centerRow = Math.floor(rows / 2);

                const gridLeft = (viewportWidth / 2) - (cellSize / 2) - (centerCol * cellSize);
                const gridTop = (viewportHeight / 2) - (cellSize / 2) - (centerRow * cellSize);

                // Set grid container's style
                container.style.width = `${gridWidth}px`;
                container.style.height = `${gridHeight}px`;
                container.style.left = `${gridLeft}px`;
                container.style.top = `${gridTop}px`;

                // Set grid template columns and rows
                container.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
                container.style.gridTemplateRows = `repeat(${rows}, ${cellSize}px)`;

                // Generate grid items
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const gridItem = document.createElement('div');
                        gridItem.className = 'grid-item';

                        // Set the grid item background image
                        gridItem.style.backgroundImage = `url('other.png')`;

                        if (row === centerRow && col === centerCol) {
                            gridItem.classList.add('center');

                            const video = document.createElement('video');
                            video.className = 'center-video';
                            video.muted = true;
                            video.playsInline = true;
                            video.setAttribute('preload', 'auto');
                            video.setAttribute('autoplay', 'true');
                            video.setAttribute('loop', 'true');

                            // Create source element for webm video
                            const sourceWebM = document.createElement('source');
                            sourceWebM.src = 'center.webm'; // Use the center video
                            sourceWebM.type = 'video/webm';

                            video.appendChild(sourceWebM);
                            gridItem.appendChild(video);

                            // Add click event to handle filters
                            gridItem.addEventListener('click', () => handleGridItemClick());

                            // Optional: Add click event directly to video if needed
                            video.addEventListener('click', (event) => {
                                event.stopPropagation(); // Prevent triggering grid item click if necessary
                                handleGridItemClick();
                            });
                        }

                        container.appendChild(gridItem);
                    }
                }

            } catch (error) {
                console.error('Error loading background image:', error);
            }
        }

        function handleGridItemClick() {
            if (isFirstClick) {
                applyInversion();
                isFirstClick = false;
            } else {
                applyRandomFilter();
            }
        }

        function applyInversion() {
            const content = document.querySelector('.content');
            if (content) {
                // Set all filter functions with invert at 100% and others at default
                content.style.filter = `
                    invert(100%)
                    hue-rotate(0deg)
                    brightness(1)
                    contrast(1)
                    saturate(1)
                    sepia(0)
                    grayscale(0)
                `;
            }
        }

        function applyRandomFilter() {
            const content = document.querySelector('.content');

            if (content) {
                // Generate random values within defined pleasant ranges
                const hueRotate = Math.floor(Math.random() * 360); // 0 to 359 degrees
                const brightness = (Math.random() * 0.4) + 0.8;  // 0.8 to 1.2
                const contrast = (Math.random() * 0.4) + 0.8;    // 0.8 to 1.2
                const saturate = (Math.random() * 0.4) + 0.8;     // 0.8 to 1.2
                const sepia = (Math.random() * 0.3).toFixed(2);   // 0.00 to 0.30
                const grayscale = (Math.random() * 0.3).toFixed(2); // 0.00 to 0.30

                // Construct the filter string without blur
                const filterString = `
                    invert(0%)
                    hue-rotate(${hueRotate}deg)
                    brightness(${brightness})
                    contrast(${contrast})
                    saturate(${saturate})
                    sepia(${sepia})
                    grayscale(${grayscale})
                `;

                // Apply the filter to the content
                content.style.filter = filterString;
            }
        }

        // Initialize grid on load and resize
        window.addEventListener('load', () => {
            createGrid();

            // Play video after user interaction (for mobile browsers)
            document.body.addEventListener('touchstart', playMedia, { once: true });
            document.body.addEventListener('click', playMedia, { once: true });

            // Initialize audio
            initializeAudio();

            // Fade out the loading overlay
            const loadingOverlay = document.getElementById('loading-overlay');
            loadingOverlay.classList.add('fade-out');
            loadingOverlay.addEventListener('transitionend', () => {
                loadingOverlay.parentNode.removeChild(loadingOverlay);
            });
        });

        window.addEventListener('resize', createGrid);

        function playMedia() {
            const video = document.querySelector('.center-video');
            if (video && video.paused) {
                video.play().catch(err => {
                    console.error('Video play failed:', err);
                });
            }

            // Also attempt to play audio if not already handled
            const audio = document.getElementById('background-audio');
            if (audio && audio.paused) {
                audio.play().catch(err => {
                    console.error('Audio play failed:', err);
                });
            }
        }

        // Audio Initialization and Mute/Unmute Functionality
        function initializeAudio() {
            const audio = document.getElementById('background-audio');
            const muteButton = document.getElementById('mute-button');
            const songCredit = document.getElementById('song-credit');

            // Attempt to play audio (will be muted by default)
            audio.play().catch(err => {
                console.error('Audio play failed:', err);
            });

            // Set initial button state based on audio mute
            updateMuteButton();

            // Add click event listener to the mute button
            muteButton.addEventListener('click', () => {
                audio.muted = !audio.muted;
                updateMuteButton();
                toggleSongCredit();
            });
        }

        function updateMuteButton() {
            const audio = document.getElementById('background-audio');
            const muteButton = document.getElementById('mute-button');

            if (audio.muted) {
                muteButton.classList.remove('unmuted');
                muteButton.setAttribute('aria-label', 'Unmute audio');
            } else {
                muteButton.classList.add('unmuted');
                muteButton.setAttribute('aria-label', 'Mute audio');
            }
        }

        function toggleSongCredit() {
            const audio = document.getElementById('background-audio');
            const songCredit = document.getElementById('song-credit');

            if (!audio.muted) {
                // Show the credit
                songCredit.classList.add('visible');

                // Automatically hide after 5 seconds
                setTimeout(() => {
                    songCredit.classList.remove('visible');
                }, 5000);
            }
        }

        // New: Color Control Functionality
        document.addEventListener('DOMContentLoaded', () => {
            const originalButton = document.getElementById('original-color-button');
            const invertedButton = document.getElementById('inverted-color-button');
            const content = document.querySelector('.content');

            originalButton.addEventListener('click', () => {
                if (content) {
                    // Reset to original colors
                    content.style.filter = `
                        invert(0%)
                        hue-rotate(0deg)
                        brightness(1)
                        contrast(1)
                        saturate(1)
                        sepia(0)
                        grayscale(0)
                    `;
                }
                isFirstClick = false; // Prevent the first click inversion
            });

            invertedButton.addEventListener('click', () => {
                if (content) {
                    // Apply inverted colors
                    content.style.filter = `
                        invert(100%)
                        hue-rotate(0deg)
                        brightness(1)
                        contrast(1)
                        saturate(1)
                        sepia(0)
                        grayscale(0)
                    `;
                }
                isFirstClick = false; // Prevent the first click inversion
            });
        });

    </script>
</body>
</html>
